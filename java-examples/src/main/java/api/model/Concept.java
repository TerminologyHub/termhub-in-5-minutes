/*
 * Terminology Hub Terminology Terminology API
 * <div>API documentation for the interacting with terminologies and concepts. <hr width=\"100%\" /><p>For a guided tour of using this API, see our github project <a target=\"_blank\" href=\"https://github.com/terminologyhub/termhub-in-5-minutes\">https://github.com/terminologyhub/termhub-in-5-minutes</a></p><hr width=\"100%\" /><p>For a local runtime container version of this API, see github project <a href=\"https://github.com/terminologyhub/open-termhub\">https://github.com/terminologyhub/open-termhub</a></p><hr width=\"100%\" /><p>Watch the video documentation on the right for more info on using is API documentation page</p></div><div id=\"video-destination\"></div>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@terminologyhub.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import api.model.Axiom;
import api.model.ConceptRef;
import api.model.ConceptRelationship;
import api.model.ConceptTreePosition;
import api.model.Definition;
import api.model.IdentifierRef;
import api.model.SubsetRef;
import api.model.Term;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import api.invoker.JSON;


/**
 * Represents a concept in a terminology
 */
@JsonPropertyOrder({
  Concept.JSON_PROPERTY_ID,
  Concept.JSON_PROPERTY_CONFIDENCE,
  Concept.JSON_PROPERTY_MODIFIED,
  Concept.JSON_PROPERTY_CREATED,
  Concept.JSON_PROPERTY_MODIFIED_BY,
  Concept.JSON_PROPERTY_LOCAL,
  Concept.JSON_PROPERTY_ACTIVE,
  Concept.JSON_PROPERTY_NAME,
  Concept.JSON_PROPERTY_CODE,
  Concept.JSON_PROPERTY_TERMINOLOGY,
  Concept.JSON_PROPERTY_VERSION,
  Concept.JSON_PROPERTY_PUBLISHER,
  Concept.JSON_PROPERTY_HISTORICAL,
  Concept.JSON_PROPERTY_LEAF,
  Concept.JSON_PROPERTY_DEFINED,
  Concept.JSON_PROPERTY_LEVEL,
  Concept.JSON_PROPERTY_TERMS,
  Concept.JSON_PROPERTY_INDEX_TERMS,
  Concept.JSON_PROPERTY_DEFINITIONS,
  Concept.JSON_PROPERTY_AXIOMS,
  Concept.JSON_PROPERTY_IDENTIFIERS,
  Concept.JSON_PROPERTY_ATTRIBUTES,
  Concept.JSON_PROPERTY_HIGHLIGHTS,
  Concept.JSON_PROPERTY_SEMANTIC_TYPES,
  Concept.JSON_PROPERTY_LABELS,
  Concept.JSON_PROPERTY_CHILDREN,
  Concept.JSON_PROPERTY_PARENTS,
  Concept.JSON_PROPERTY_DESCENDANTS,
  Concept.JSON_PROPERTY_ANCESTORS,
  Concept.JSON_PROPERTY_SUBSETS,
  Concept.JSON_PROPERTY_RELATIONSHIPS,
  Concept.JSON_PROPERTY_INVERSE_RELATIONSHIPS,
  Concept.JSON_PROPERTY_TREE_POSITIONS
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-12T13:13:49.637811500-07:00[America/Los_Angeles]", comments = "Generator version: 7.5.0")
public class Concept {
  public static final String JSON_PROPERTY_ID = "id";
  private UUID id;

  public static final String JSON_PROPERTY_CONFIDENCE = "confidence";
  private Double confidence;

  public static final String JSON_PROPERTY_MODIFIED = "modified";
  private OffsetDateTime modified;

  public static final String JSON_PROPERTY_CREATED = "created";
  private OffsetDateTime created;

  public static final String JSON_PROPERTY_MODIFIED_BY = "modifiedBy";
  private String modifiedBy;

  public static final String JSON_PROPERTY_LOCAL = "local";
  private Boolean local;

  public static final String JSON_PROPERTY_ACTIVE = "active";
  private Boolean active;

  public static final String JSON_PROPERTY_NAME = "name";
  private String name;

  public static final String JSON_PROPERTY_CODE = "code";
  private String code;

  public static final String JSON_PROPERTY_TERMINOLOGY = "terminology";
  private String terminology;

  public static final String JSON_PROPERTY_VERSION = "version";
  private String version;

  public static final String JSON_PROPERTY_PUBLISHER = "publisher";
  private String publisher;

  public static final String JSON_PROPERTY_HISTORICAL = "historical";
  private String historical;

  public static final String JSON_PROPERTY_LEAF = "leaf";
  private Boolean leaf;

  public static final String JSON_PROPERTY_DEFINED = "defined";
  private Boolean defined;

  public static final String JSON_PROPERTY_LEVEL = "level";
  private Integer level;

  public static final String JSON_PROPERTY_TERMS = "terms";
  private List<Term> terms = new ArrayList<>();

  public static final String JSON_PROPERTY_INDEX_TERMS = "indexTerms";
  private List<String> indexTerms = new ArrayList<>();

  public static final String JSON_PROPERTY_DEFINITIONS = "definitions";
  private List<Definition> definitions = new ArrayList<>();

  public static final String JSON_PROPERTY_AXIOMS = "axioms";
  private List<Axiom> axioms = new ArrayList<>();

  public static final String JSON_PROPERTY_IDENTIFIERS = "identifiers";
  private List<IdentifierRef> identifiers = new ArrayList<>();

  public static final String JSON_PROPERTY_ATTRIBUTES = "attributes";
  private Map<String, String> attributes = new HashMap<>();

  public static final String JSON_PROPERTY_HIGHLIGHTS = "highlights";
  private Map<String, String> highlights = new HashMap<>();

  public static final String JSON_PROPERTY_SEMANTIC_TYPES = "semanticTypes";
  private Set<String> semanticTypes = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_LABELS = "labels";
  private Set<String> labels = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_CHILDREN = "children";
  private List<ConceptRef> children = new ArrayList<>();

  public static final String JSON_PROPERTY_PARENTS = "parents";
  private List<ConceptRef> parents = new ArrayList<>();

  public static final String JSON_PROPERTY_DESCENDANTS = "descendants";
  private List<ConceptRef> descendants = new ArrayList<>();

  public static final String JSON_PROPERTY_ANCESTORS = "ancestors";
  private List<ConceptRef> ancestors = new ArrayList<>();

  public static final String JSON_PROPERTY_SUBSETS = "subsets";
  private List<SubsetRef> subsets = new ArrayList<>();

  public static final String JSON_PROPERTY_RELATIONSHIPS = "relationships";
  private List<ConceptRelationship> relationships = new ArrayList<>();

  public static final String JSON_PROPERTY_INVERSE_RELATIONSHIPS = "inverseRelationships";
  private List<ConceptRelationship> inverseRelationships = new ArrayList<>();

  public static final String JSON_PROPERTY_TREE_POSITIONS = "treePositions";
  private List<ConceptTreePosition> treePositions = new ArrayList<>();

  public Concept() { 
  }

  public Concept id(UUID id) {
    this.id = id;
    return this;
  }

   /**
   * Unique identifier
   * @return id
  **/
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(UUID id) {
    this.id = id;
  }


  public Concept confidence(Double confidence) {
    this.confidence = confidence;
    return this;
  }

   /**
   * Confidence value (for use with search results)
   * @return confidence
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CONFIDENCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Double getConfidence() {
    return confidence;
  }


  @JsonProperty(JSON_PROPERTY_CONFIDENCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConfidence(Double confidence) {
    this.confidence = confidence;
  }


  public Concept modified(OffsetDateTime modified) {
    this.modified = modified;
    return this;
  }

   /**
   * Last modified date
   * @return modified
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MODIFIED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getModified() {
    return modified;
  }


  @JsonProperty(JSON_PROPERTY_MODIFIED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setModified(OffsetDateTime modified) {
    this.modified = modified;
  }


  public Concept created(OffsetDateTime created) {
    this.created = created;
    return this;
  }

   /**
   * Created date
   * @return created
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OffsetDateTime getCreated() {
    return created;
  }


  @JsonProperty(JSON_PROPERTY_CREATED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public Concept modifiedBy(String modifiedBy) {
    this.modifiedBy = modifiedBy;
    return this;
  }

   /**
   * Last modified by
   * @return modifiedBy
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MODIFIED_BY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getModifiedBy() {
    return modifiedBy;
  }


  @JsonProperty(JSON_PROPERTY_MODIFIED_BY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setModifiedBy(String modifiedBy) {
    this.modifiedBy = modifiedBy;
  }


  public Concept local(Boolean local) {
    this.local = local;
    return this;
  }

   /**
   * Indicates whether this data element is locally created
   * @return local
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOCAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getLocal() {
    return local;
  }


  @JsonProperty(JSON_PROPERTY_LOCAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLocal(Boolean local) {
    this.local = local;
  }


  public Concept active(Boolean active) {
    this.active = active;
    return this;
  }

   /**
   * Indicates whether or not the component is active
   * @return active
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getActive() {
    return active;
  }


  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setActive(Boolean active) {
    this.active = active;
  }


  public Concept name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Concept name
   * @return name
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(String name) {
    this.name = name;
  }


  public Concept code(String code) {
    this.code = code;
    return this;
  }

   /**
   * Terminology code, typically representing a unit of meaning
   * @return code
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCode() {
    return code;
  }


  @JsonProperty(JSON_PROPERTY_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCode(String code) {
    this.code = code;
  }


  public Concept terminology(String terminology) {
    this.terminology = terminology;
    return this;
  }

   /**
   * Terminology abbreviation
   * @return terminology
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTerminology() {
    return terminology;
  }


  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTerminology(String terminology) {
    this.terminology = terminology;
  }


  public Concept version(String version) {
    this.version = version;
    return this;
  }

   /**
   * Terminology version
   * @return version
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getVersion() {
    return version;
  }


  @JsonProperty(JSON_PROPERTY_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVersion(String version) {
    this.version = version;
  }


  public Concept publisher(String publisher) {
    this.publisher = publisher;
    return this;
  }

   /**
   * Terminology publisher
   * @return publisher
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PUBLISHER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPublisher() {
    return publisher;
  }


  @JsonProperty(JSON_PROPERTY_PUBLISHER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPublisher(String publisher) {
    this.publisher = publisher;
  }


  public Concept historical(String historical) {
    this.historical = historical;
    return this;
  }

   /**
   * Historical relationship type (only used for concept descendants)
   * @return historical
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_HISTORICAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getHistorical() {
    return historical;
  }


  @JsonProperty(JSON_PROPERTY_HISTORICAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHistorical(String historical) {
    this.historical = historical;
  }


  public Concept leaf(Boolean leaf) {
    this.leaf = leaf;
    return this;
  }

   /**
   * Indicates whether or not this concept is a leaf node in its hierarchy
   * @return leaf
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LEAF)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getLeaf() {
    return leaf;
  }


  @JsonProperty(JSON_PROPERTY_LEAF)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLeaf(Boolean leaf) {
    this.leaf = leaf;
  }


  public Concept defined(Boolean defined) {
    this.defined = defined;
    return this;
  }

   /**
   * Indicates whether or not this concept has a logical definition with necessary and sufficient conditions
   * @return defined
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DEFINED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getDefined() {
    return defined;
  }


  @JsonProperty(JSON_PROPERTY_DEFINED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDefined(Boolean defined) {
    this.defined = defined;
  }


  public Concept level(Integer level) {
    this.level = level;
    return this;
  }

   /**
   * Level of depth
   * @return level
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LEVEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getLevel() {
    return level;
  }


  @JsonProperty(JSON_PROPERTY_LEVEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLevel(Integer level) {
    this.level = level;
  }


  public Concept terms(List<Term> terms) {
    this.terms = terms;
    return this;
  }

  public Concept addTermsItem(Term termsItem) {
    if (this.terms == null) {
      this.terms = new ArrayList<>();
    }
    this.terms.add(termsItem);
    return this;
  }

   /**
   * Terms associated with the concept
   * @return terms
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TERMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Term> getTerms() {
    return terms;
  }


  @JsonProperty(JSON_PROPERTY_TERMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTerms(List<Term> terms) {
    this.terms = terms;
  }


  public Concept indexTerms(List<String> indexTerms) {
    this.indexTerms = indexTerms;
    return this;
  }

  public Concept addIndexTermsItem(String indexTermsItem) {
    if (this.indexTerms == null) {
      this.indexTerms = new ArrayList<>();
    }
    this.indexTerms.add(indexTermsItem);
    return this;
  }

   /**
   * Index terms associated with the concept (these exist for searchability but are not strictly content from the publisher)
   * @return indexTerms
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INDEX_TERMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getIndexTerms() {
    return indexTerms;
  }


  @JsonProperty(JSON_PROPERTY_INDEX_TERMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIndexTerms(List<String> indexTerms) {
    this.indexTerms = indexTerms;
  }


  public Concept definitions(List<Definition> definitions) {
    this.definitions = definitions;
    return this;
  }

  public Concept addDefinitionsItem(Definition definitionsItem) {
    if (this.definitions == null) {
      this.definitions = new ArrayList<>();
    }
    this.definitions.add(definitionsItem);
    return this;
  }

   /**
   * Textual definitions associated with the concept
   * @return definitions
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DEFINITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Definition> getDefinitions() {
    return definitions;
  }


  @JsonProperty(JSON_PROPERTY_DEFINITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDefinitions(List<Definition> definitions) {
    this.definitions = definitions;
  }


  public Concept axioms(List<Axiom> axioms) {
    this.axioms = axioms;
    return this;
  }

  public Concept addAxiomsItem(Axiom axiomsItem) {
    if (this.axioms == null) {
      this.axioms = new ArrayList<>();
    }
    this.axioms.add(axiomsItem);
    return this;
  }

   /**
   * OwL/RDF axioms that express the logical definition
   * @return axioms
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_AXIOMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Axiom> getAxioms() {
    return axioms;
  }


  @JsonProperty(JSON_PROPERTY_AXIOMS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAxioms(List<Axiom> axioms) {
    this.axioms = axioms;
  }


  public Concept identifiers(List<IdentifierRef> identifiers) {
    this.identifiers = identifiers;
    return this;
  }

  public Concept addIdentifiersItem(IdentifierRef identifiersItem) {
    if (this.identifiers == null) {
      this.identifiers = new ArrayList<>();
    }
    this.identifiers.add(identifiersItem);
    return this;
  }

   /**
   * Alternate identifiers associated with the concept
   * @return identifiers
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_IDENTIFIERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<IdentifierRef> getIdentifiers() {
    return identifiers;
  }


  @JsonProperty(JSON_PROPERTY_IDENTIFIERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIdentifiers(List<IdentifierRef> identifiers) {
    this.identifiers = identifiers;
  }


  public Concept attributes(Map<String, String> attributes) {
    this.attributes = attributes;
    return this;
  }

  public Concept putAttributesItem(String key, String attributesItem) {
    if (this.attributes == null) {
      this.attributes = new HashMap<>();
    }
    this.attributes.put(key, attributesItem);
    return this;
  }

   /**
   * Attribute key/value pairs associated with the concept
   * @return attributes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, String> getAttributes() {
    return attributes;
  }


  @JsonProperty(JSON_PROPERTY_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAttributes(Map<String, String> attributes) {
    this.attributes = attributes;
  }


  public Concept highlights(Map<String, String> highlights) {
    this.highlights = highlights;
    return this;
  }

  public Concept putHighlightsItem(String key, String highlightsItem) {
    if (this.highlights == null) {
      this.highlights = new HashMap<>();
    }
    this.highlights.put(key, highlightsItem);
    return this;
  }

   /**
   * Used by search calls to provide information for highlighting a view of results
   * @return highlights
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_HIGHLIGHTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, String> getHighlights() {
    return highlights;
  }


  @JsonProperty(JSON_PROPERTY_HIGHLIGHTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHighlights(Map<String, String> highlights) {
    this.highlights = highlights;
  }


  public Concept semanticTypes(Set<String> semanticTypes) {
    this.semanticTypes = semanticTypes;
    return this;
  }

  public Concept addSemanticTypesItem(String semanticTypesItem) {
    if (this.semanticTypes == null) {
      this.semanticTypes = new LinkedHashSet<>();
    }
    this.semanticTypes.add(semanticTypesItem);
    return this;
  }

   /**
   * High level semantic types associated with the concept
   * @return semanticTypes
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEMANTIC_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<String> getSemanticTypes() {
    return semanticTypes;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_SEMANTIC_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSemanticTypes(Set<String> semanticTypes) {
    this.semanticTypes = semanticTypes;
  }


  public Concept labels(Set<String> labels) {
    this.labels = labels;
    return this;
  }

  public Concept addLabelsItem(String labelsItem) {
    if (this.labels == null) {
      this.labels = new LinkedHashSet<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

   /**
   * Labels associated with the concept
   * @return labels
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<String> getLabels() {
    return labels;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLabels(Set<String> labels) {
    this.labels = labels;
  }


  public Concept children(List<ConceptRef> children) {
    this.children = children;
    return this;
  }

  public Concept addChildrenItem(ConceptRef childrenItem) {
    if (this.children == null) {
      this.children = new ArrayList<>();
    }
    this.children.add(childrenItem);
    return this;
  }

   /**
   * Children of the concept in the hierarchy
   * @return children
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CHILDREN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRef> getChildren() {
    return children;
  }


  @JsonProperty(JSON_PROPERTY_CHILDREN)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChildren(List<ConceptRef> children) {
    this.children = children;
  }


  public Concept parents(List<ConceptRef> parents) {
    this.parents = parents;
    return this;
  }

  public Concept addParentsItem(ConceptRef parentsItem) {
    if (this.parents == null) {
      this.parents = new ArrayList<>();
    }
    this.parents.add(parentsItem);
    return this;
  }

   /**
   * Parents of the concept in the hierarchy
   * @return parents
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PARENTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRef> getParents() {
    return parents;
  }


  @JsonProperty(JSON_PROPERTY_PARENTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParents(List<ConceptRef> parents) {
    this.parents = parents;
  }


  public Concept descendants(List<ConceptRef> descendants) {
    this.descendants = descendants;
    return this;
  }

  public Concept addDescendantsItem(ConceptRef descendantsItem) {
    if (this.descendants == null) {
      this.descendants = new ArrayList<>();
    }
    this.descendants.add(descendantsItem);
    return this;
  }

   /**
   * Descendants of the concept in the hierarchy
   * @return descendants
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DESCENDANTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRef> getDescendants() {
    return descendants;
  }


  @JsonProperty(JSON_PROPERTY_DESCENDANTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescendants(List<ConceptRef> descendants) {
    this.descendants = descendants;
  }


  public Concept ancestors(List<ConceptRef> ancestors) {
    this.ancestors = ancestors;
    return this;
  }

  public Concept addAncestorsItem(ConceptRef ancestorsItem) {
    if (this.ancestors == null) {
      this.ancestors = new ArrayList<>();
    }
    this.ancestors.add(ancestorsItem);
    return this;
  }

   /**
   * Ancestors of the concept in the hierarchy
   * @return ancestors
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ANCESTORS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRef> getAncestors() {
    return ancestors;
  }


  @JsonProperty(JSON_PROPERTY_ANCESTORS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAncestors(List<ConceptRef> ancestors) {
    this.ancestors = ancestors;
  }


  public Concept subsets(List<SubsetRef> subsets) {
    this.subsets = subsets;
    return this;
  }

  public Concept addSubsetsItem(SubsetRef subsetsItem) {
    if (this.subsets == null) {
      this.subsets = new ArrayList<>();
    }
    this.subsets.add(subsetsItem);
    return this;
  }

   /**
   * Subsets the concept is a part of from the same terminology loader
   * @return subsets
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SUBSETS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<SubsetRef> getSubsets() {
    return subsets;
  }


  @JsonProperty(JSON_PROPERTY_SUBSETS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSubsets(List<SubsetRef> subsets) {
    this.subsets = subsets;
  }


  public Concept relationships(List<ConceptRelationship> relationships) {
    this.relationships = relationships;
    return this;
  }

  public Concept addRelationshipsItem(ConceptRelationship relationshipsItem) {
    if (this.relationships == null) {
      this.relationships = new ArrayList<>();
    }
    this.relationships.add(relationshipsItem);
    return this;
  }

   /**
   * Relationships from this concept to other concepts
   * @return relationships
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RELATIONSHIPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRelationship> getRelationships() {
    return relationships;
  }


  @JsonProperty(JSON_PROPERTY_RELATIONSHIPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRelationships(List<ConceptRelationship> relationships) {
    this.relationships = relationships;
  }


  public Concept inverseRelationships(List<ConceptRelationship> inverseRelationships) {
    this.inverseRelationships = inverseRelationships;
    return this;
  }

  public Concept addInverseRelationshipsItem(ConceptRelationship inverseRelationshipsItem) {
    if (this.inverseRelationships == null) {
      this.inverseRelationships = new ArrayList<>();
    }
    this.inverseRelationships.add(inverseRelationshipsItem);
    return this;
  }

   /**
   * Relationships from other concepts to this concept
   * @return inverseRelationships
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INVERSE_RELATIONSHIPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptRelationship> getInverseRelationships() {
    return inverseRelationships;
  }


  @JsonProperty(JSON_PROPERTY_INVERSE_RELATIONSHIPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInverseRelationships(List<ConceptRelationship> inverseRelationships) {
    this.inverseRelationships = inverseRelationships;
  }


  public Concept treePositions(List<ConceptTreePosition> treePositions) {
    this.treePositions = treePositions;
    return this;
  }

  public Concept addTreePositionsItem(ConceptTreePosition treePositionsItem) {
    if (this.treePositions == null) {
      this.treePositions = new ArrayList<>();
    }
    this.treePositions.add(treePositionsItem);
    return this;
  }

   /**
   * Tree positions of the concept in the hierarchy
   * @return treePositions
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TREE_POSITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ConceptTreePosition> getTreePositions() {
    return treePositions;
  }


  @JsonProperty(JSON_PROPERTY_TREE_POSITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTreePositions(List<ConceptTreePosition> treePositions) {
    this.treePositions = treePositions;
  }


  /**
   * Return true if this Concept object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Concept concept = (Concept) o;
    return Objects.equals(this.id, concept.id) &&
        Objects.equals(this.confidence, concept.confidence) &&
        Objects.equals(this.modified, concept.modified) &&
        Objects.equals(this.created, concept.created) &&
        Objects.equals(this.modifiedBy, concept.modifiedBy) &&
        Objects.equals(this.local, concept.local) &&
        Objects.equals(this.active, concept.active) &&
        Objects.equals(this.name, concept.name) &&
        Objects.equals(this.code, concept.code) &&
        Objects.equals(this.terminology, concept.terminology) &&
        Objects.equals(this.version, concept.version) &&
        Objects.equals(this.publisher, concept.publisher) &&
        Objects.equals(this.historical, concept.historical) &&
        Objects.equals(this.leaf, concept.leaf) &&
        Objects.equals(this.defined, concept.defined) &&
        Objects.equals(this.level, concept.level) &&
        Objects.equals(this.terms, concept.terms) &&
        Objects.equals(this.indexTerms, concept.indexTerms) &&
        Objects.equals(this.definitions, concept.definitions) &&
        Objects.equals(this.axioms, concept.axioms) &&
        Objects.equals(this.identifiers, concept.identifiers) &&
        Objects.equals(this.attributes, concept.attributes) &&
        Objects.equals(this.highlights, concept.highlights) &&
        Objects.equals(this.semanticTypes, concept.semanticTypes) &&
        Objects.equals(this.labels, concept.labels) &&
        Objects.equals(this.children, concept.children) &&
        Objects.equals(this.parents, concept.parents) &&
        Objects.equals(this.descendants, concept.descendants) &&
        Objects.equals(this.ancestors, concept.ancestors) &&
        Objects.equals(this.subsets, concept.subsets) &&
        Objects.equals(this.relationships, concept.relationships) &&
        Objects.equals(this.inverseRelationships, concept.inverseRelationships) &&
        Objects.equals(this.treePositions, concept.treePositions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, confidence, modified, created, modifiedBy, local, active, name, code, terminology, version, publisher, historical, leaf, defined, level, terms, indexTerms, definitions, axioms, identifiers, attributes, highlights, semanticTypes, labels, children, parents, descendants, ancestors, subsets, relationships, inverseRelationships, treePositions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Concept {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    confidence: ").append(toIndentedString(confidence)).append("\n");
    sb.append("    modified: ").append(toIndentedString(modified)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    modifiedBy: ").append(toIndentedString(modifiedBy)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    active: ").append(toIndentedString(active)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    terminology: ").append(toIndentedString(terminology)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    publisher: ").append(toIndentedString(publisher)).append("\n");
    sb.append("    historical: ").append(toIndentedString(historical)).append("\n");
    sb.append("    leaf: ").append(toIndentedString(leaf)).append("\n");
    sb.append("    defined: ").append(toIndentedString(defined)).append("\n");
    sb.append("    level: ").append(toIndentedString(level)).append("\n");
    sb.append("    terms: ").append(toIndentedString(terms)).append("\n");
    sb.append("    indexTerms: ").append(toIndentedString(indexTerms)).append("\n");
    sb.append("    definitions: ").append(toIndentedString(definitions)).append("\n");
    sb.append("    axioms: ").append(toIndentedString(axioms)).append("\n");
    sb.append("    identifiers: ").append(toIndentedString(identifiers)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    highlights: ").append(toIndentedString(highlights)).append("\n");
    sb.append("    semanticTypes: ").append(toIndentedString(semanticTypes)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    children: ").append(toIndentedString(children)).append("\n");
    sb.append("    parents: ").append(toIndentedString(parents)).append("\n");
    sb.append("    descendants: ").append(toIndentedString(descendants)).append("\n");
    sb.append("    ancestors: ").append(toIndentedString(ancestors)).append("\n");
    sb.append("    subsets: ").append(toIndentedString(subsets)).append("\n");
    sb.append("    relationships: ").append(toIndentedString(relationships)).append("\n");
    sb.append("    inverseRelationships: ").append(toIndentedString(inverseRelationships)).append("\n");
    sb.append("    treePositions: ").append(toIndentedString(treePositions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

