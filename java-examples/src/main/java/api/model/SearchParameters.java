/*
 * Terminology Hub Terminology Terminology API
 * API documentation for the interacting with terminologies and concepts. <p>For a guided tour of using this API, see our github project <a target=\"_blank\" href=\"https://github.com/terminologyhub/termhub-in-5-minutes\">https://github.com/terminologyhub/termhub-in-5-minutes</a></p>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@terminologyhub.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package api.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import api.invoker.JSON;


/**
 * Represents parameters for a &#39;find&#39; call.
 */
@JsonPropertyOrder({
  SearchParameters.JSON_PROPERTY_TERMINOLOGY,
  SearchParameters.JSON_PROPERTY_QUERY,
  SearchParameters.JSON_PROPERTY_EXPRESSION,
  SearchParameters.JSON_PROPERTY_FILTERS,
  SearchParameters.JSON_PROPERTY_LIMIT,
  SearchParameters.JSON_PROPERTY_OFFSET,
  SearchParameters.JSON_PROPERTY_ACTIVE,
  SearchParameters.JSON_PROPERTY_SORT,
  SearchParameters.JSON_PROPERTY_ASCENDING,
  SearchParameters.JSON_PROPERTY_LEAF
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-04T13:11:42.646293800-07:00[America/Los_Angeles]", comments = "Generator version: 7.5.0")
public class SearchParameters {
  public static final String JSON_PROPERTY_TERMINOLOGY = "terminology";
  private String terminology;

  public static final String JSON_PROPERTY_QUERY = "query";
  private String query;

  public static final String JSON_PROPERTY_EXPRESSION = "expression";
  private String expression;

  public static final String JSON_PROPERTY_FILTERS = "filters";
  private Map<String, String> filters = new HashMap<>();

  public static final String JSON_PROPERTY_LIMIT = "limit";
  private Integer limit;

  public static final String JSON_PROPERTY_OFFSET = "offset";
  private Integer offset;

  public static final String JSON_PROPERTY_ACTIVE = "active";
  private Boolean active;

  public static final String JSON_PROPERTY_SORT = "sort";
  private List<String> sort = new ArrayList<>();

  public static final String JSON_PROPERTY_ASCENDING = "ascending";
  private Boolean ascending;

  public static final String JSON_PROPERTY_LEAF = "leaf";
  private Boolean leaf;

  public SearchParameters() { 
  }

  public SearchParameters terminology(String terminology) {
    this.terminology = terminology;
    return this;
  }

   /**
   * Terminology filter, e.g. &#39;SNOMEDCT&#39;
   * @return terminology
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTerminology() {
    return terminology;
  }


  @JsonProperty(JSON_PROPERTY_TERMINOLOGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTerminology(String terminology) {
    this.terminology = terminology;
  }


  public SearchParameters query(String query) {
    this.query = query;
    return this;
  }

   /**
   * Search query, e.g. &#39;aspirin&#39;
   * @return query
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_QUERY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getQuery() {
    return query;
  }


  @JsonProperty(JSON_PROPERTY_QUERY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setQuery(String query) {
    this.query = query;
  }


  public SearchParameters expression(String expression) {
    this.expression = expression;
    return this;
  }

   /**
   * Search expression, e.g. &#39;&lt;&lt; 404684003&#39;
   * @return expression
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getExpression() {
    return expression;
  }


  @JsonProperty(JSON_PROPERTY_EXPRESSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setExpression(String expression) {
    this.expression = expression;
  }


  public SearchParameters filters(Map<String, String> filters) {
    this.filters = filters;
    return this;
  }

  public SearchParameters putFiltersItem(String key, String filtersItem) {
    if (this.filters == null) {
      this.filters = new HashMap<>();
    }
    this.filters.put(key, filtersItem);
    return this;
  }

   /**
   * Additional field level filters (to specify that certain fields must have certain values)
   * @return filters
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, String> getFilters() {
    return filters;
  }


  @JsonProperty(JSON_PROPERTY_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFilters(Map<String, String> filters) {
    this.filters = filters;
  }


  public SearchParameters limit(Integer limit) {
    this.limit = limit;
    return this;
  }

   /**
   * Limit on number of results, e.g. 10
   * @return limit
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LIMIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getLimit() {
    return limit;
  }


  @JsonProperty(JSON_PROPERTY_LIMIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLimit(Integer limit) {
    this.limit = limit;
  }


  public SearchParameters offset(Integer offset) {
    this.offset = offset;
    return this;
  }

   /**
   * Starting index for results, e.g. 0
   * @return offset
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_OFFSET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getOffset() {
    return offset;
  }


  @JsonProperty(JSON_PROPERTY_OFFSET)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOffset(Integer offset) {
    this.offset = offset;
  }


  public SearchParameters active(Boolean active) {
    this.active = active;
    return this;
  }

   /**
   * Specifically search for &#39;active only&#39; or &#39;inactive only&#39;
   * @return active
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getActive() {
    return active;
  }


  @JsonProperty(JSON_PROPERTY_ACTIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setActive(Boolean active) {
    this.active = active;
  }


  public SearchParameters sort(List<String> sort) {
    this.sort = sort;
    return this;
  }

  public SearchParameters addSortItem(String sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * Field of the data model being searched to sort by
   * @return sort
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SORT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getSort() {
    return sort;
  }


  @JsonProperty(JSON_PROPERTY_SORT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSort(List<String> sort) {
    this.sort = sort;
  }


  public SearchParameters ascending(Boolean ascending) {
    this.ascending = ascending;
    return this;
  }

   /**
   * Used with &#39;sort&#39; to indicate ascending or descending
   * @return ascending
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ASCENDING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getAscending() {
    return ascending;
  }


  @JsonProperty(JSON_PROPERTY_ASCENDING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAscending(Boolean ascending) {
    this.ascending = ascending;
  }


  public SearchParameters leaf(Boolean leaf) {
    this.leaf = leaf;
    return this;
  }

   /**
   * Specifically search for &#39;leaf only&#39; or &#39;leaf only&#39;
   * @return leaf
  **/
  @jakarta.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LEAF)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getLeaf() {
    return leaf;
  }


  @JsonProperty(JSON_PROPERTY_LEAF)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLeaf(Boolean leaf) {
    this.leaf = leaf;
  }


  /**
   * Return true if this SearchParameters object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchParameters searchParameters = (SearchParameters) o;
    return Objects.equals(this.terminology, searchParameters.terminology) &&
        Objects.equals(this.query, searchParameters.query) &&
        Objects.equals(this.expression, searchParameters.expression) &&
        Objects.equals(this.filters, searchParameters.filters) &&
        Objects.equals(this.limit, searchParameters.limit) &&
        Objects.equals(this.offset, searchParameters.offset) &&
        Objects.equals(this.active, searchParameters.active) &&
        Objects.equals(this.sort, searchParameters.sort) &&
        Objects.equals(this.ascending, searchParameters.ascending) &&
        Objects.equals(this.leaf, searchParameters.leaf);
  }

  @Override
  public int hashCode() {
    return Objects.hash(terminology, query, expression, filters, limit, offset, active, sort, ascending, leaf);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchParameters {\n");
    sb.append("    terminology: ").append(toIndentedString(terminology)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    expression: ").append(toIndentedString(expression)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    offset: ").append(toIndentedString(offset)).append("\n");
    sb.append("    active: ").append(toIndentedString(active)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    ascending: ").append(toIndentedString(ascending)).append("\n");
    sb.append("    leaf: ").append(toIndentedString(leaf)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

